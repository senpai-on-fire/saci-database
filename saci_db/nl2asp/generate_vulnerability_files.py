import os
import sys
import time
from dotenv import load_dotenv
from openai import OpenAI


def main():
    # Step 1: Get the vulnerability description from the user
    print(
        "Please enter the natural language description of a cyber vulnerability (end with Ctrl+D):"
    )
    vulnerability_description = sys.stdin.read()

    # Step 2: Craft the prompt and send it to ChatGPT
    prompt = craft_prompt(vulnerability_description)

    # Load the .env file
    load_dotenv()
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        print("Error: OPENAI_API_KEY is not set.")
        sys.exit(1)

    # Step 3: Call the OpenAI API with timing
    print("Thinking...")
    start_time = time.time()
    client = OpenAI(api_key=api_key)
    response = call_openai_api(client, prompt)
    end_time = time.time()
    elapsed_time = end_time - start_time
    print(f"Thought for {elapsed_time:.2f} seconds")

    # Output the entire OpenAI response for debugging
    # print("\nOpenAI API Response for debugging purposes:")
    # print(response)

    # Step 4: Parse the response to get the .lp file, questions, and mapping
    lp_file_content, questions, mapping_content = parse_response(response)

    # Save the .lp file
    with open("vulnerability.lp", "w") as f:
        f.write(lp_file_content)

    # Save the questions to a file
    with open("questions.txt", "w") as f:
        for question in questions:
            f.write(question + "\n")

    # Save the mapping to a file
    with open("instructions.txt", "w") as f:
        f.write(mapping_content)

    print(
        "Files 'vulnerability.lp', 'questions.txt', and 'instructions.txt' have been generated."
    )


def craft_prompt(vulnerability_description):
    prompt = f"""
Given the following description of a cyber vulnerability:

{vulnerability_description}

Please:

1. Summarize the necessary conditions about the device to trigger the vulnerability.

2. Generate an .lp file (for Answer Set Programming) that describes the atoms and the necessary logic to trigger the vulnerability.

3. Provide a set of questions for the user to answer so that they can decide the values of the atoms.

   - **Important:** When generating the questions, please use language that would be understandable to someone familiar with the device specifications.

4. Provide a mapping from each question to the corresponding atom(s) in the .lp file.

Please format your response as follows:

===BEGIN_LP_FILE===
[Your .lp file content here]
===END_LP_FILE===

===BEGIN_QUESTIONS===
[Your list of questions here]
===END_QUESTIONS===

===BEGIN_MAPPING===
[Question to atom mapping here]
===END_MAPPING===
"""
    return prompt


def call_openai_api(client, prompt):
    try:
        response = client.chat.completions.create(
            model="o1-preview", messages=[{"role": "user", "content": prompt}]
        )
        return response.choices[0].message.content
    except Exception as e:
        print("An error occurred while calling the OpenAI API:", e)
        sys.exit(1)


def parse_response(response_text):
    # Extract the .lp file content, questions, and mapping from the response
    lp_file_content = ""
    questions = []
    mapping_content = ""

    in_lp_file = False
    in_questions = False
    in_mapping = False

    for line in response_text.splitlines():
        if line.strip() == "===BEGIN_LP_FILE===":
            in_lp_file = True
            continue
        elif line.strip() == "===END_LP_FILE===":
            in_lp_file = False
            continue
        elif line.strip() == "===BEGIN_QUESTIONS===":
            in_questions = True
            continue
        elif line.strip() == "===END_QUESTIONS===":
            in_questions = False
            continue
        elif line.strip() == "===BEGIN_MAPPING===":
            in_mapping = True
            continue
        elif line.strip() == "===END_MAPPING===":
            in_mapping = False
            continue

        if in_lp_file:
            lp_file_content += line + "\n"
        elif in_questions:
            if line.strip():
                questions.append(line.strip())
        elif in_mapping:
            mapping_content += line + "\n"

    return lp_file_content, questions, mapping_content


if __name__ == "__main__":
    main()
